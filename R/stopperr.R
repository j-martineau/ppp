# check whether Dots are named
.all_named <- function(...) {
  n    <- base::...length()
  labs <- base::...names()
  if (n == 0) {F} else if (base::length(labs) != n) {F} else {!base::any(base::is.na(labs))}
}

# simple oxford comma lists
.ox_vals <- function(x, join) {
  n <- base::length(x)
  if (n == 1) {x} else if (n == 2) {base::paste0(x[1], " ", join, " ", x[2])} else {base::paste0(base::paste0(x[1:(n - 1)], collapse = ", "), ", ", join, " ", x[n])}
}

#' @encoding UTF-8
#' @family Errs
#' @title Error checking, banking, and processing
#' @description Bank error messages in the immediate environment of a function to allow for exhaustive error checking before throwing an exception. Results in a possibly multiple-error, accumulated message to be processed upon completion of error checking.
#' @details **Primary stopping functions**
#' \tabular{ll}{  `stopperr` or `stopper`   \tab Stops execution by:                                                                                                                                                                                                             \cr
#'                                          \tab \enumerate{
#'                                                  \item Posting an \code{\link{alert}} header the console with the following components: an error `'ERROR'` title, a subheader identifying the function Where the error originated (from `FUN`), and another subheader identifying the package that function belongs to (from `.pkg`).
#'                                                  \item Posting one or more error message to the console following the header, each preceded by a bullet, Where each element of each `...` arg is a separate error message.
#'                                                  \item Creating a \code{\link[base]{simpleError}} object with an error message consisting of an \link[=lineage]{abbreviated function call lineage} given as a vector in `.stack`.
#'                                                  \item Attaching the function identity, package identity, and associated message(s) to the `simpleError` object as attributes.
#'                                                  \item Archiving the `simpleError` object in the global variable `.ppp_LAST_ERR_ppp.` (which can be retrieved by calling `getter()` and can be purged by calling `purger()`). Allows for error tracing in the circumstance that R purges the last error in final error processing.
#'                                                  \item Calling `stop` with the `simpleError` object as the argument.                                                                                                                                           } \cr   \tab   \cr
#'                `checkerr` or `checker`   \tab Calls `stopper` with any error messages banked by the functions described in sections *error banking* *utilities functions* and *condition-based error-checking functions*. If none are banked, does nothing.      \cr   \tab   \cr
#'                `purgerr` or `purger`     \tab Purges the most recent \code{\link[base]{simpleError}} object generated by this family of functions.                                                                                                               \cr   \tab   \cr
#'                `getterr` or `getter`     \tab Gets the most recent `simpleError` object generated by this family of functions.                                                                                                                                                  }
#' \cr Both `stopperr / stopper` and `checkerr / checker` can identify error-generating functions further up the call Stack than the function in which they are called:
#' \itemize{\item `stopperr / stopper` uses args `.fun`, `.pkg`, and `.stack` to identify the error-generating function.
#'          \item `checkerr / checker` uses args `.gens` and `.pkg` to identify the error-generating function.}
#' \cr\cr **Secondary stopping functions**
#' \cr\cr These functions are designed to be called directly from the function Where an error is generated. It gathers the name of the function generating the error rather than requiring the user to provide the function name. These functions operate as follows:
#' \tabular{ll}{  `Errs`            \tab Calls `stopperr` treating each element of each `...` arg as a separate error message, allowing for compiling multiple error message before processing.                                                              \cr   \tab   \cr
#'                `err`             \tab Calls `stopperr` with a single error message constructed by \link[=collapse_dots]{collapsing} all elements of all `...` args into a character scalar error message before processing.                                              }
#' \cr\cr **Multiple-error conditional stopping functions**
#' \cr\cr These functions conditionally compile multiple errors, and if any are compiled, they notify the user and stop execution.
#' \tabular{ll}{  `errs_if_nots`    \tab Conditionally compiles errors, treating each odd-numbered `...` arg as a test and each even-numbered `...` arg as the corresponding error message if the test is `FALSE`, and calls `stopperr` if any are compiled. \cr   \tab   \cr
#'                `errs_if_pop`     \tab Calls `stopperr` if there are any `...` args, treating each `...` arg as a separate error message.                                                                                                                  \cr   \tab   \cr
#'                `errs_ifs`        \tab Conditionally compiles errors, treating each odd-numbered `...` arg as a test and each even-numbered `...` arg as the corresponding error message if the test is `TRUE`, and calls `stopperr` if any are compiled.                 }
#' \cr\cr **Single-error conditional stopping functions**
#' \cr\cr These functions conditionally construct a single error, and if one is constructed, they notify the user and stop execution.
#' \tabular{ll}{  `err_if_pop`      \tab If there are any `...` args, collapsing them into a character scalar error message, and calls `stopperr`.                                                                                                           \cr   \tab   \cr
#'                `err_if_not`      \tab If `TEST = FALSE`, collapses `...` args to a character scalar error message and calls `stopperr`.                                                                                                                   \cr   \tab   \cr
#'                `err_if`          \tab If `TEST = TRUE`, collapses `...` args to a character scalar error message and calls `stopperr`.                                                                                                                                   }
#' \cr\cr **Utility functions**
#' \cr\cr These functions purge and retrieve the most recent error generated by this family of functions.
#' \cr\cr **Primary error banking functions**
#' \cr\cr Error banking utility functions: These functions are utilities for banking user-defined error messages within a function to allow for checking for multiple errors in separate statements and banking those error messages as they are checked, waiting to process banked error messages until an error checking block is completed. These functions also allow for generating and checking for error messages further up the call Stack than the function in which the error banking/processing occurs by specifying the number of generations back in the call Stack Where error banking/processing occurs in `.gens`:
#' \tabular{ll}{  `banked_Errs`     \tab Retrieves the bank of error message stored in the environment of the function `.gens` generations back in the call Stack.                                                                                            \cr   \tab   \cr
#'                `bankErrs`        \tab Banks each element of \link[=cmp_chr_vec]{complete character vec} as an individual error message.                                                                                                                   \cr   \tab   \cr
#'                `bankerr`         \tab Banks an arbitrary error message (built by \link[=collapse_dots]{collapsing} `...` args) in the environment of the function `.gens` generations back in the call Stack.                                                             }
#' \cr\cr **Error checking / conditional error banking functions**
#' \cr\cr **`checkerr`** checks for any banked error messages. If there are any, processes them and stops execution. Otherwise, does nothing.
#' \cr\cr The remaining **`check_{props}`** functions in the following table check objects for specific properties and automatically generate errors only if those properties are not met:
#' \tabular{ll}{  `check_nas_or`    \tab A named `...` arg is neither `NULL` nor satisfies any property function named in `.funs`.                                                                                                                           \cr   \tab   \cr
#'                `check_nll_or`    \tab A named `...` arg is neither scalar `NA` nor satisfies any property function named in `.funs`.                                                                                                                      \cr   \tab   \cr
#'                `check_chars`     \tab A named `...` arg contains characters not supplied in `CHARS`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_when`      \tab The first named `...` arg *is* the `n`-th value in `WHENS`, but the second *is not* the `n`-th value in `.vals`.                                                                                                    \cr   \tab   \cr
#'                `check_dots`      \tab A `...` arg\eqn{^{(1)}} fails to satisfy the \link[=is_prop_spec]{property spec} in `SPEC`.                                                                                                                        \cr   \tab   \cr
#'                `check_spec`      \tab A named `...` arg fails to satisfy the \link[=is_prop_spec]{property spec} in `SPEC`\eqn{^{(2)}}.                                                                                                                  \cr   \tab   \cr
#'                `check_funs`      \tab A named `...` arg fails to satisfy *any* of the \link[=prop_funs]{property function(s)} named in `.funs`.                                                                                                           \cr   \tab   \cr
#'                `check_vals`      \tab A named `...` arg contains values not supplied in `.vals`.                                                                                                                                                          \cr   \tab   \cr
#'                `check_fail`      \tab A named `...` arg produces an error when submitted to \code{\link[base]{identity}}.                                                                                                                                \cr   \tab   \cr
#'                `check_cls`       \tab A named `...` arg is not of any class named in `CLS`.                                                                                                                                                              \cr   \tab   \cr
#'                `check_lgl`       \tab A named `...` arg is neither `TRUE`, `FALSE`, `NA` (if `.na = TRUE`), nor contained in `EXTRAS`.                                                                                                                   \cr   \tab   \cr
#'                `check_pop`       \tab A named `...` arg is either `NULL` or otherwise of length `0`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_tf`        \tab A named `...` arg is neither scalar `TRUE` nor scalar `FALSE`.                                                                                                                                                     \cr   \tab   \cr
#'                `check_t`         \tab A named `...` arg is `FALSE`\eqn{^{(3)}}.                                                                                                                                                                          \cr   \tab     }
#'  \tabular{l}{  \eqn{^{(1)}} Named if `NAMED = TRUE`.                                                                                                             \cr
#'                \eqn{^{(2)}} May be scalar `NA` if `.na = TRUE`.                                                                                                  \cr
#'                \eqn{^{(3)}} Collapses *unnamed* `...` args to an error message template, replacing the escape sequence `'{@@}'` with the *named* `...` arg's name. }
#' @section The `...` arguments: Arguments supplied in `...` differ across functions in terms of whether they are named, how many named and/or unnamed `...` args there are, and their \link[=ppp]{property requirements} as follows:
#' \tabular{llll}{                  \tab    **Number of** `...` **args**          \tab                                            \tab           \cr
#'                  **Function**    \tab    *NAMED*                               \tab   *UNNAMED*                                \tab   *TOTAL* \cr
#'                  `check_chars`   \tab    `1+` (\code{\link{atm_str}})          \tab   `1+` (\code{\link{atm_chr}}\eqn{^{(1)}}) \tab   `2+`    \cr
#'                  `check_when`    \tab    `2 ` (\code{\link{atm_scl}})          \tab   `2 ` (\code{\link{atm_scl}})             \tab   `4`     \cr
#'                  `check_vals`    \tab    `1+` (\code{\link{ATM}}\eqn{^{(1)}})  \tab   `1+` (\code{\link{ATM}}\eqn{^{(1)}})     \tab   `2+`    \cr
#'                  `check_dots`    \tab    `1+` (any object\eqn{^{(2)}})         \tab   `0 ` (any object\eqn{^{(2)}})            \tab   `1+`    \cr
#'                  `check_fail`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_funs`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_spec`    \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_cls`     \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_lgl`     \tab    `1+` (\code{\link{atm_scl}})          \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_pop`     \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_tf`      \tab    `1+` (any object)                     \tab   `0`                                      \tab   `1+`    \cr
#'                  `check_t`       \tab    `1+` (\code{\link{is_tf0}})           \tab   `0`                                      \tab   `1+`    \cr
#'                  `stopperr`      \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`    \cr
#'                  `stopper`       \tab                                          \tab                                            \tab           \cr
#'                  `Errs`          \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`    \cr
#'                  `err`           \tab    `0+` (\code{\link{cmp_chr_vec}})      \tab   `0+` (\code{\link{cmp_chr_vec}})         \tab   `1+`      }
#'    \tabular{l}{  \eqn{^{(1)}} When `A = TRUE`.                    \cr
#'                  \eqn{^{(2)}} When `NAMED = TRUE` (otherwise `0+`). }
#' @param ... Differs by function in terms of whether they are named, how many there are, and their \link[=ppp]{property requirements} as described in section *the* `...` *arguments*.
#' @param .a A logical scalar indicating whether to \link[=av]{atomize} `...` args.
#' @param .d A non-`NA` character scalar delimiter for collapsing `...` into a an error message.
#' @param .fun A character scalar naming the function generating an error or errors.
#' @param .na A logical scalar indicating whether `NA` values qualify as `'logical'`.
#' @param .pkg A character scalar naming the package `FUN` is a part of. The package is identified as `'unknown'` when `.pkg = ""`.
#' @param .errs A character vector of individual error messages.
#' @param .gens A \link[=cmp_nnw_scl]{complete non-negative whole-number scalar} indicating the number of generations back in the call Stack in which to bank and/or check for error messages.
#' @param .funs A \link[=cmp_chr_vec]{complete character vec} containing `1` or more \link[=prop_funs]{property function} names.
#' @param .spec A \link[=cmp_chr_scl]{complete character scalar} containing a \link[=is_prop_spec]{property spec}.
#' @param .chars A \link[=cmp_str]{complete string object} containing
#' @param .named A logical scalar indicating whether `...` args must uniquely named without using `""`.
#' @param .stack An optional character vector naming the lineage of the function generating the error. If `NULL`, retrieves the Stack under the assumption that the immediate calling function is Where the error is generated.
#' @param .whens A \link[=pop_atm]{populated atomic object} of length `length(.vals)`.
#' @param .vals A \link[=cmp_atm]{complete atomic object} of length `length(.whens)`.
#' @param .test A non-`NA` logical scalar.
#' @param .extras `NULL` or a \link[=cmp_atm]{complete atomic object} containing additional valid values.
#' @return **A **\code{\link[base]{simpleError}} **object** \cr\cr `getterr`
#' \cr\cr  **A character vector**                           \cr\cr `banked_Errs`
#' \cr\cr  All others are called for their side effects.
#' @examples
#' egStopper <- function() {stopperr('stopper demo', .pkg = 'ppp')}
#' egErrs    <- function() {Errs('Errs demo1', 'Errs demo2', .pkg = 'ppp')}
#' egErr     <- function() {err('err', 'demo', .pkg = 'ppp')}
#' egErrors  <- function(..., tf = NA, lgl = 42, not = FALSE, pop = NULL,
#'                            fail = simpleError('error'), funs = 2:4, spec = 42,
#'                            vals = 42, class = 42, nas.or = NULL, nll.or = NA,
#'                            chars = '5', when.a = "error.a", when.b = "error.b") {
#'   bankerr(...elt(1))
#'   bankErrs(...elt(2), ...elt(3))
#'   check_tf(tf = tf)
#'   check_lgl(lgl = lgl)
#'   check_t(not = not)
#'   check_pop(pop = pop)
#'   check_fail(fail = fail)
#'   check_funs(c('cmp_ch1_vec', 'cmp_ngw_vec'), funs = funs)
#'   check_spec('cmp_ch1_vec|nll|nas', spec = spec)
#'   check_vals(letters, vals = vals)
#'   check_cls('data.frame', class)
#'   check_nas_or(c('cmp_ch1_vec', 'cmp_ngw_vec'), nas.or = nas.or)
#'   check_nll_or(c('cmp_ch1_vec', 'cmp_ngw_vec'), nll.or = nll.or)
#'   check_chars(letters, chars = chars)
#'   check_when(when.a = when.a, when.b = when.b, c('error.a', ''), c('error.b', ''))
#'   checkerr(.pkg = 'ppp')
#' }
#' \dontrun{
#'   egstopperr()
#'   getterr()
#'   purgerr()
#'   getter()
#'   egErrs()
#'   egErrs()
#'   egErrors()
#' }
#' @export
stopperr <- function(..., .fun = "", .pkg = "", .stack = "") {
  .rwb <- function(X) {crayon::bgRed(crayon::white(crayon::bold(X)))}
  .bwp <- function(X) {crayon::bgBlack(crayon::white(X))}
  .byi <- function(X) {crayon::bgBlack(crayon::yellow(crayon::italic(X)))}
  if (uj::is_err(.fun)) {.fun <- ""} else if (!base::is.character(.fun) | base::length(.fun) != 1) {.fun <- ""} else if (base::is.na(.fun)) {.fun <- ""}
  if (uj::is_err(.pkg)) {.pkg <- ""} else if (!base::is.character(.pkg) | base::length(.pkg) != 1) {.pkg <- ""} else if (base::is.na(.pkg)) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- ""} else if (!base::is.character(.stack) | base::length(.stack) == 0) {.stack <- ""} else if (base::any(base::is.na(.stack))) {.stack <- ""}
  errs <- base::as.character(ppp::av(uj::failsafe(base::list(...))))
  errs[base::trimws(errs, which = "both", whitespace = "[ \t\r]") == ""] <- "[unknown.error]"
  errs <- base::unique(errs)
  if (.fun == "") {.fun <- uj::caller()}
  if (.pkg == "") {.pkg <- "[??]"}
  if (base::length(.stack) == 1) {if (.stack == "") {.stack <- uj::callers()}}
  .fun    <- uj:::.stack2funs(.fun, 100)
  .pkg    <- base::substr(.pkg, 1, base::min(100, base::nchar(.pkg)))
  .stack  <- uj:::.stack2pkgfuns(.stack, 35)
  errLab  <- " ERROR IN  "
  funLab  <- " function: "
  pkgLab  <- " package:  "
  funLen  <- base::nchar(.fun)
  pkgLen  <- base::nchar(.pkg)
  padLen  <- base::max(base::nchar(.fun), base::nchar(.pkg)) + 1
  spaces  <- base::paste0(base::rep.int(" ", 101), collapse = "")
  errPad  <- base::substr(spaces, 1, padLen)
  funPad  <- base::substr(spaces, 1, padLen - funLen)
  pkgPad  <- base::substr(spaces, 1, padLen - pkgLen)
  suff    <- base::ifelse(base::length(errs) > 1, "S", "")
  mssg    <- base::paste0(base::paste0(base::paste0("\n  \u2022 ", errs), collapse = ""), "\n\n")
  base::cat("\n"); base::cat(base::gsub(" ", " ", base::paste0(.rwb(errLab), .rwb(errPad))))
  base::cat("\n"); base::cat(base::gsub(" ", " ", base::paste0(.byi(funLab), .bwp(base::paste0(.fun, funPad)))))
  base::cat("\n"); base::cat(base::gsub(" ", " ", base::paste0(.byi(pkgLab), .bwp(base::paste0(.pkg, pkgPad)))))
  base::cat("\n")
  .stack    <- base::paste0(base::paste0("\n  \u2022 ", .stack), collapse = "")
  errObj <- base::paste0("\nFUNCTION\n  \u2022 ", .fun, "\n\nPACKAGE\n  \u2022 ", .pkg, "\n\nCALL STACK ", .stack, "\n\nERROR MESSAGE", suff, mssg)
  errObj <- base::simpleError(errObj)
  base::assign(".ppp_LAST_ERR_ppp.", errObj, envir = .GlobalEnv)
  stop(mssg)
}

#' @rdname stopperr
#' @export
getterr <- function() {if (base::exists(".ppp_LAST_ERR_ppp.", envir = base::.GlobalEnv)) {base::get(".ppp_LAST_ERR_ppp.", envir = .GlobalEnv)} else {NULL}}

#' @rdname stopperr
#' @export
purgerr <- function() {if (base::exists(".ppp_LAST_ERR_ppp.", envir = .GlobalEnv)) {base::rm(".ppp_LAST_ERR_ppp.", envir = .GlobalEnv)}}

#' @rdname stopperr
#' @export
stopper <- stopperr

#' @rdname stopperr
#' @export
getter <- getterr

#' @rdname stopperr
#' @export
purger <- purgerr

#' @rdname stopperr
#' @export
err_if <- function(.test, ..., .fun = "", .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (          base::is.na(.d    ) ) {.d <- " "}
  if (uj::is_err(.fun  )) {.fun   <- "" } else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- "" } else if (          base::is.na(.fun  ) ) {.fun <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (          base::is.na(.pkg  ) ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  if (base::isTRUE(.test)) {
    err <- base::paste0(ppp::av(uj::failsafe(base::list(...))), collapse = .d)
    if (err == "") {err <- "[unknown.error]"}
    where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
    ppp::stopperr(err, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
  }
}

#' @rdname stopperr
#' @export
err_if_not <- function(.test, ..., .fun = "", .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (          base::is.na(.d    ) ) {.d <- " "}
  if (uj::is_err(.fun  )) {.fun   <- "" } else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- "" } else if (          base::is.na(.fun  ) ) {.fun <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (          base::is.na(.pkg  ) ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  if (!base::isTRUE(uj::failsafe(.test))) {
    err <- base::trimws(base::paste0(ppp::av(uj::failsafe(base::list(...))), collapse = .d), which = "both", whitespace = "[ \t\r]")
    if (err == "") {err <- "[unknown.error]"}
    where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
    ppp::stopperr(err, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
  }
}

#' @rdname stopperr
#' @export
errs_ifs <- function(..., .fun = "", .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (          base::is.na(.d    ) ) {.d <- " "}
  if (uj::is_err(.fun  )) {.fun   <- "" } else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- "" } else if (          base::is.na(.fun  ) ) {.fun <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (          base::is.na(.pkg  ) ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  n <- base::...length()
  if (n / 2 == base::round(n / 2)) {
    errs <- NULL
    for (i in 1:(n - 1)) {
      test <- uj::failsafe(base::...elt(i))
      if (base::isTRUE(test)) {
        err <- base::paste0(ppp::av(uj::failsafe(base::...elt(i + 1))), collapse = .d)
        if (err == "") {err <- "[unknown.error]"}
        errs <- base::c(errs, err)
      }
    }
    if (!base::is.null(errs)) {
      errs  <- base::unique(errs)
      where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
      ppp::stopperr(errs, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
    }
  } else {ppp::stopperr("There must be an even number of [...] args.", .pkg = "ppp", .stack = uj::callers())}
}

#' @rdname stopperr
#' @export
errs_if_nots <- function(..., .fun = "", .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (          base::is.na(.d    ) ) {.d <- " "}
  if (uj::is_err(.fun  )) {.fun   <- "" } else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- "" } else if (          base::is.na(.fun  ) ) {.fun <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (          base::is.na(.pkg  ) ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  n <- base::...length()
  if (n / 2 == base::round(n / 2)) {
    errs <- NULL
    for (i in 1:(n - 1)) {
      test <- uj::failsafe(base::...elt(i))
      if (!base::isTRUE(test)) {
        err <- base::paste0(ppp::av(uj::failsafe(base::...elt(i + 1))), collapse = .d)
        if (err == "") {err <- "[unknown.error]"}
        errs <- base::c(errs, err)
      }
    }
    if (!base::is.null(errs)) {
      errs <- base::unique(errs)
      where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
      ppp::stopperr(errs, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
    }
  } else {ppp::stopperr("There must be an even number of [...] args.", .pkg = "ppp", .stack = uj::callers())}
}

#' @rdname stopperr
#' @export
err_if_pop <- function(..., .fun = "", .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (          base::is.na(.d    ) ) {.d <- " "}
  if (uj::is_err(.fun  )) {.fun   <- "" } else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- "" } else if (          base::is.na(.fun  ) ) {.fun <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (          base::is.na(.pkg  ) ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  if (base::...length() > 0) {
    errs <- NULL
    for (i in 1:base::...length()) {
      piece <- uj::failsafe(base::...elt(i))
      if (!base::is.null(piece)) {
        if (!uj::is_err(piece)) {errs <- base::c(errs, base::as.character(piece))}
        else {errs <- base::c(errs, "")}
      }
    }
    if (base::length(errs) > 0) {
      errs <- base::paste0(errs, collapse = .d)
      if (errs == "") {errs <- "[unknown.error]"}
      where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
      ppp::stopperr(errs, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
    }
  }
}

#' @rdname stopperr
#' @export
errs_if_pop <- function(..., .fun = "", .pkg = "", .stack = "") {
  if (uj::is_err(.fun  )) {.fun   <- ""} else if (!base::is.character(.fun  ) | base::length(.fun  ) != 1) {.fun   <- ""} else if (          base::is.na(.fun  ) ) {.fun   <- ""}
  if (uj::is_err(.pkg  )) {.pkg   <- ""} else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- ""} else if (          base::is.na(.pkg  ) ) {.pkg   <- ""}
  if (uj::is_err(.stack)) {.stack <- ""} else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- ""} else if (base::any(base::is.na(.stack))) {.stack <- ""}
  errs <- uj::failsafe(base::list(...))
  errs <- base::as.character(ppp::av(errs))
  errs[base::is.na(errs)] <- "[unknown.error]"
  if (base::length(errs) == 1) {if (errs == "") {errs <- NULL}}
  if (base::length(errs) > 0) {
    errs[errs == ""] <- "[unknown.error]"
    errs <- base::unique(errs)
    where <- uj:::.fun_pkg_stack(.fun, .pkg, .stack, uj::caller(), uj::callers())
    ppp::stopperr(errs, .fun = where$fun, .pkg = where$pkg, .stack = where$stack)
  }
}


#' @rdname stopperr
#' @export
errs <- function(.errs, .pkg = "", .stack = "") {
  if (uj::is_err(.pkg  )) {.pkg   <- ""} else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- ""} else if (          base::is.na(.pkg  ) ) {.pkg   <- ""}
  if (uj::is_err(.stack)) {.stack <- ""} else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- ""} else if (base::any(base::is.na(.stack))) {.stack <- ""}
  .errs <- base::as.character(uj::failsafe(.errs))
  .errs <- base::trimws(base::as.character(ppp::av(.errs)), which = "both")
  .errs[base::is.na(.errs)] <- "[unknown.error]"
  .errs[.errs == ""] <- "[unknown.error]"
  .errs <- base::unique(.errs)
  ppp::stopperr(.errs, .fun = uj::caller(), .pkg = .pkg, .stack = uj::callers())
}

#' @rdname stopperr
#' @export
err <- function(..., .pkg = "", .stack = "", .d = " ") {
  if (uj::is_err(.d    )) {.d     <- " "} else if (!base::is.character(.d    ) | base::length(.d    ) != 1) {.d     <- " "} else if (base::is.na(.d)               ) {.d <- " "}
  if (uj::is_err(.pkg  )) {.pkg   <- "" } else if (!base::is.character(.pkg  ) | base::length(.pkg  ) != 1) {.pkg   <- "" } else if (base::is.na(.pkg)             ) {.pkg <- ""}
  if (uj::is_err(.stack)) {.stack <- "" } else if (!base::is.character(.stack) | base::length(.stack) != 1) {.stack <- "" } else if (base::any(base::is.na(.stack))) {.stack <- ""}
  err <- base::paste0(ppp::av(uj::failsafe(base::list(...))), collapse = .d)
  err <- base::trimws(err, which = "both")
  if (base::is.na(err)) {err <- "[unknown.error]"}
  if (err != ""       ) {err <- "[unknown.error]"}
  ppp::stopperr(err, .fun = uj::caller(), .pkg = .pkg, .stack = uj::callers())
}

#' @rdname stopperr
#' @export
banked_errs <- function(.gens = 0) {
  if ( uj::is_err(.gens)        ) {.gens <- 0}
  if (!ppp:::.cmp_psw_scl(.gens)) {.gens <- 0}
  .gens <- .gens + 1
  if (base::exists(".ppp_ERR_BANK_ppp.", envir = base::parent.frame(.gens), inherits = F)) {base::get(".ppp_ERR_BANK_ppp.", envir = base::parent.frame(.gens), inherits = F)} else {NULL}
}

#' @rdname stopperr
#' @export
checkerr <- function(.gens = 0, .pkg = "") {
  if (uj::is_err(.gens)) {.gens <- 0} else if (!ppp:::.cmp_psw_scl(.gens)) {.gens <- 0}
  if (uj::is_err(.pkg )) {.pkg <- ""} else if (!base::is.character(.pkg) | base::length(.pkg) != 1) {.pkg <- ""} else if (base::is.na(.pkg)) {.pkg <- ""}
  .gens <- .gens + 1
  .stack <- uj::callers()
  .stack <- .stack[.gens:base::length(.stack)]
  if (base::exists(".ppp_ERR_BANK_ppp.", envir = base::parent.frame(.gens), inherits = F)) {
    .fun <- uj::callerN(.gens + 1)
    errs <- base::get(".ppp_ERR_BANK_ppp.", envir = base::parent.frame(.gens), inherits = F)
    base::rm(list = ".ppp_ERR_BANK_ppp.", envir = base::parent.frame(.gens), inherits = F);
    ppp::stopperr(errs, .fun = .fun, .pkg = .pkg, .stack = .stack)
  }
}

#' @rdname stopperr
#' @export
checker <- checkerr

#' @rdname stopperr
#' @export
bankerr <- function(..., .gens = 0, .d = "") {
  if (uj::is_err(.gens)) {.gens <- 0  } else if (!ppp:::.cmp_psw_scl(.gens)) {.gens <- 0}
  if (uj::is_err(.d   )) {.d    <- " "} else if (!base::is.character(.d) | base::length(.d) != 1) {.d <- " "} else if (base::is.na(.d)) {.d <- " "}
  .gens <- .gens + 1
  err <- base::paste0(ppp::av(uj::failsafe(base::list(...))), collapse = .d)
  err <- base::trimws(err, which = "both")
  if (base::is.na(err)) {err <- "[unknown.error]"}
  if (err == "") {err <- "[unknown.error]"}
  errs <- base::c(ppp::banked_errs(.gens), errs)
  base::assign(".ppp_ERR_BANK_ppp.", errs, envir = base::parent.frame(.gens))
}

#' @rdname stopperr
#' @export
bankErrs <- function(..., .gens = 0) {
  if (uj::is_err(.gens)) {.gens <- 0} else if (!ppp:::.cmp_psw_scl(.gens)) {.gens <- 0}
  .gens <- .gens + 1
  if (base::...length() > 0) {
    errs <- NULL
    for (i in 1:base::...length()) {
      err <- base::paste0(base::as.character(ppp::av(uj::failsafe(base::...elt(i)))), collapse = "")
      err <- base::trimws(err, which = "both")
      if (base::is.na(err)) {err <- "[unknown.error]"}
      if (err == ""       ) {err <- "[unknown.error]"}
      errs <- base::c(errs, err)
    }
  } else {errs <- "{ unknown error } "}
  errs <- base::unique(base::c(ppp::banked_errs(.gens), errs))
  base::assign(".ppp_ERR_BANK_ppp.", errs, envir = base::parent.frame(.gens))
}

#' @rdname stopperr
#' @export
check_t <- function(..., .d = " ") {
  if (uj::is_err(.d)) {.d <- " "} else if (!base::is.character(.d) | base::length(.d) != 1) {.d <- " "} else if (base::is.na(.d)) {.d <- " "}
  dots <- uj::named_dots(...)
  anon <- uj::anon_dots(...)
  mssg <- base::paste0(uj::av(anon), collapse = .d)
  labs <- base::names(dots)
  errs <- NULL
  if (base::length(dots) == 0                               ) {errs <- base::c(errs, "There are no named [...] args."                                                                                  )}
  if (base::length(anon) != base::length(base::unique(labs))) {errs <- base::c(errs, "Named [...] args must be uniquely named."                                                                        )}
  if (base::length(anon) == 0                               ) {errs <- base::c(errs, "There are no unnamed [...] args."                                                                                )}
  if (!base::any(base::grepl("{@}", mssg, fixed = TRUE))    ) {errs <- base::c(errs, "At least 1 unnamed [...] arg must contain the escape sequence '{@}' for inserting the names of named [...] args.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  for (i in 1:base::length(dots)) {if (!dots[[1]]) {ppp::bankerr(base::gsub("{@}", base::paste0("[", labs[i], "]"), mssg, fixed = T), .gens = 1)}}
}

#' @rdname stopperr
#' @export
check_tf <- function(...) {
  errs <- NULL
  if (base::...length() == 0) {errs <- base::c(errs, "There are no [...] args")}
  if (!ppp:::.all_named(...)) {errs <- base::c(errs, "All [...] args must be uniquely named without using \"\".")}
  if (!base::is.null(errs)  ) {ppp::stopperr(errs, .pkg = "ppp")}
  labs <- base::...names()
  dots <- base::list(...)
  ok   <- base::sapply(dots, base::isTRUE) | base::sapply(dots, base::isFALSE)
  for (i in 1:base::length(ok)) {if (!ok[i]) {ppp::bankerr("[", labs[i], "] must be scalar TRUE or scalar FALSE.", .gens = 1, .d = "")}}
}

#' @rdname stopperr
#' @export
check_lgl <- function(..., .na = FALSE, .extras = NULL) {
  if (ppp::.cmp_lgl_scl(.na)) {    .na <- .na    } else {.na     <- F   }
  if (ppp::.cmp_atm(.extras)) {.extras <- .extras} else {.extras <- NULL}
  errs    <- NULL
  if (base::...length() > 0) {errs <- base::c(errs, "There are no [...] args")}
  if (ppp:::.all_named(...)) {errs <- base::c(errs, "All [...] args must be uniquely named without using \"\".")}
  if (!base::is.null(errs) ) {ppp::stopperr(errs, .pkg = "ppp")}
  X <- base::list(...)
  if (!(base::all(base::sapply(X, ppp:::.atm_scl)))) {ppp::stopperr("All [...] args must be atomic scalars.", .pkg = "ppp")}
  ok <- base::sapply(X, base::isFALSE)
  if (.na) {ok <- ok & base::all(base::is.na(X))}
  if (!base::all(ok)) {
    labs <- base::paste0("[", base::...names()[!ok], "]")
    if (base::length(labs) > 1) {mults <- base::c("s", "")} else {mults <- base::c("", "s")}
    vals <- base::c("TRUE", "FALSE")
    if (.na) {vals <- base::c(vals, "NA")}
    if (!base::is.null(.extras)) {
      if (base::is.character(.extras)) {vals <- base::c(vals, base::paste0("'", .extras, "'"))}
      else {vals <- base::c(vals, base::as.character(.extras))}
    }
    err <- base::paste0("Argument", mults[1], ppp:::.ox_vals(labs, "and"), "contain", mults[2], " one or more values not in {", ppp:::.ox_vals(vals, "and"), "}.")
    ppp::bankerr(err, .gens = 1)
  }
}

#' @rdname stopperr
#' @export
check_nll_or <- function(.funs, ..., .vals = NULL) {
  .funs  <- uj::failsafe(.funs)
  .vals  <- uj::failsafe(.vals)
  errs <- NULL
  if (uj::is_err(.funs)         ) {errs <- base::c(errs, "[.funs] must be a complete string vec (?cmp_str_vec).")}
  if (uj::is_err(.vals)         ) {errs <- base::c(errs, "[.vals] must be NULL or a valid R object.")}
  if (!base::is.null(errs)      ) {ppp::stopperr(errs, .pkg = "ppp")}
  if (!ppp:::.cmp_chr_vec(.funs)) {ppp::stopperr("[.funs] must be a complete string vec (?cmp_str_vec).")}
  .funs  <- ppp::av(base::strsplit(.funs, "|", TRUE))
  okFuns <- base::all(.funs %in% ppp::prop_funs())
  labs   <- base::...names()
  nX     <- base::...length()
  okX    <- nX > 0
  if (!okX                ) {okLabs <- T} else {okLabs <- ppp:::.all_named(...)}
  if (base::is.null(.vals)) {okVals <- T} else {okVals <- ppp::.cmp_vals(.vals)}
  if (!okX   ) {errs <- base::c(errs, "[...] arguments must be supplied.")}
  if (!okLabs) {errs <- base::c(errs, "[...] args must be uniquely named without using blank strings.")}
  if (!okFuns) {errs <- base::c(errs, "[.funs] must contain 1+ function names found in prop_funs().")}
  if (!okVals) {errs <- base::c(errs, "[.vals] must be NULL or complete and atomic (?cmp_atm).")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  errs <- base::paste0("[", labs, "] must be NULL or ", ppp::spec_concise(.funs))
  for (i in 1:nX) {if (!base::is.null(base::...elt(i))) {
    ok <- F
    for (fun in .funs) {
      ok <- ok | base::eval(base::parse(text = base::paste0(Fun, "(base::...elt(i))")))
      if (ok & !base::is.null(.vals)) {ok <- ok & base::all(base::...elt(i) %in% .vals)}
    }
    if (!ok) {ppp::bankerr(errs[i], .gens = 1)}
  }}
}

#' @rdname stopperr
#' @export
check_nas_or <- function(.funs, ..., .vals = NULL) {
  .funs  <- uj::failsafe(.funs)
  .vals  <- uj::failsafe(.vals)
  errs <- NULL
  if (uj::is_err(.funs)        ) {errs <- base::c(errs, "[.funs] must be a complete string vec (?cmp_str_vec).")}
  if (uj::is_err(.vals)        ) {errs <- base::c(errs, "[.vals] must be NULL or a valid R object.")}
  if (!base::is.null(errs)     ) {ppp::stopperr(errs, .pkg = "ppp")}
  if (!ppp::.cmp_str_vec(.funs)) {ppp::stopperr("[.funs] must be a complete string vec (?cmp_str_vec).")}
  .funs  <- ppp::av(base::strsplit(.funs, "|", TRUE))
  okFuns <- base::all(.funs %in% ppp::prop_funs())
  labs   <- base::...names()
  nX     <- base::...length()
  okX    <- nX > 0
  if (!okX                ) {okLabs <- T} else {OkLabs <- ppp:::.all_named(...)}
  if (base::is.null(.vals)) {okVals <- T} else {okVals <- ppp::.cmp_atm(.vals) }
  if (!okX   ) {errs <- base::c(errs, "[...] okVals must be supplied.")}
  if (!okLabs) {errs <- base::c(errs, "[...] args must be uniquely named without using blank strings.")}
  if (!okFuns) {errs <- base::c(errs, "[.funs] must contain 1+ function names found in prop_funs().")}
  if (!okVals) {errs <- base::c(errs, "[.vals] must be NULL or complete and atomic (?cmp_atm).")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  errs <- base::paste0("[", labs, "] must be scalar NA or ", ppp::spec_concise(.funs))
  for (i in 1:nX) {if (!ppp::.NA0(base::...elt(i))) {
    ok <- F
    for (fun in .funs) {
      ok <- ok | base::eval(base::parse(text = base::paste0(fun, "(base::...elt(i))")))
      if (ok & !base::is.null(.vals)) {ok <- ok & base::all(base::...elt(i) %in% .vals)}
    }
    if (!ok) {ppp::bankerr(errs[i], .gens = 1)}
  }}
}

#' @rdname stopperr
#' @export
check_cls <- function(.cls, ...) {
  if (uj::is_err(.cls)) {ppp::stopperr("[.cls] must be a complete character vec (?cmp_chr_vec)", .pkg = "ppp")}
  dots   <- uj::named_dots(...)
  anon   <- uj::anon_dots(...)
  labs   <- base::names(dots)
  okN    <- (base::length(dots) + base::length(anon)) > 0
  okLabs <- base::length(anon) == 0
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  okCls  <- ppp::.cmp_chr_vec(.cls)
  errs   <- NULL
  if (!okN   ) {errs <- base::c(errs, "There are no [...] args.")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!okCls ) {errs <- base::c(errs, "[.cls] must be a complete character vec (?cmp_chr_vec).")}
  if (!okLabs) {errs <- base::c(errs, "All [...] args must be named.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  .cls <- ppp::av(base::strsplit(.cls, "|", fixed = T))
  mssg <- base::paste0("'", .cls, "'")
  n    <- base::length(mssg)
  if      (n == 1) {mssg <- base::paste0("class ", mssg)}
  else if (n == 2) {mssg <- base::paste0("class ", mssg[1], " or ", mssg[2])}
  else             {mssg <- base::paste0("any class in c(", paste0(mssg, collapse = ", "), ")")}
  for (i in 1:base::length(dots)) {
    classes <- base::class(dots[[i]])
    if (!base::any(.cls %in% classes)) {ppp::bankerr("[", labs[i], "] must be of ", mssg, ".", .gens = 1, .d = "")}
  }
}

#' @rdname stopperr
#' @export
check_pop <- function(...) {
  dots   <- uj::named_dots(...)
  anon   <- uj::anon_dots(...)
  labs   <- base::names(dots)
  okN    <- base::...length() > 0
  okDots <- base::length(anon) == 0
  okAnon <- !base::any(labs == "")
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  errs   <- NULL
  if (!okN   ) {errs <- base::c(errs, "There are no [...] args.")}
  if (!okDots) {errs <- base::c(errs, "All [...] args must be named.")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\").")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  for (i in 1:base::length(dots)) {if (base::length(dots[[i]]) == 0) {ppp::bankerr("[", labs[i], "] is NULL or empty.", .gens = 1, .d = "")}}
}

#' @rdname stopperr
#' @export
check_funs <- function(.funs, ..., .vals = NULL) {
  if (!ppp::.cmp_chr_vec(.funs)) {ppp::stopperr("[.funs] must be a complete character vec (?cmp_chr_vec).", .pkg = "ppp")}
  .funs   <- ppp::av(base::strsplit(.funs, "|", TRUE))
  labs    <- base::...names()
  n       <- base::...length()
  okN     <- n > 0
  okDots  <- base::length(labs) == n
  okAnon  <- !base::any(labs == "")
  okUnq   <- base::length(labs) == base::length(base::unique(labs))
  okFuns  <- base::all(base::sapply(.funs, ppp::is_prop_fun))
  okVals  <- base::ifelse(base::is.null(.vals), T, ppp::.cmp_atm(.vals))
  errs    <- NULL
  if (!okN   ) {errs <- base::c(errs, "[...] arguments must be supplied.")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!okFuns) {errs <- base::c(errs, "[.funs] contains a function name not found in ppp::prop_funs().")}
  if (!okVals) {errs <- base::c(errs, "[.vals] must be NULL or complete and atomic (?cmp_atm).")}
  if (!okDots) {errs <- base::c(errs, "all [...] args must be named.")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\")")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  errs <- base::paste0("[", labs, "] must have the following properties: ", ppp::spec_concise(.funs))
  for (i in 1:n) {
    dot <- base::...elt(i)
    ok  <- FALSE
    for (fun in .funs) {if (!ok) {ok <- base::eval(base::parse(text = base::paste0("ppp::", fun, "(dot)")))}}
    if (!ok) {ppp::bankerr(errs[i], .gens = 1)}
  }
}

#' @rdname stopperr
#' @export
check_spec <- function(.spec, ..., .na = F) {
  n      <- base::...length()
  labs   <- base::...names()
  okN    <- n > 0
  okNas  <- uj::fs_na(.na)
  okDots <- base::length(labs) == n
  okAnon <- !base::any(labs == "")
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  okSpec <- ppp::.cmp_chr_scl(.spec)
  if (okSpec) {
    combos <- ppp::av(base::strsplit(.spec, "|", fixed = TRUE))
    for (combo in combos) {
      props <- ppp::av(base::strsplit(combo, "_", fixed = T))
      if (!base::all(base::tolower(props) %in% ppp::all_props())) {okSpec <- F}
      else if (base::length(props) != base::length(base::unique(props))) {okSpec <- F}
    }
  }
  errs <- NULL
  if (!okN   ) {errs <- base::c(errs, "[...] is empty.")}
  if (!okNas ) {errs <- base::c(errs, "[.na] must be TRUE or FALSE.")}
  if (!okDots) {errs <- base::c(errs, "all [...] args mut be named.")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank.")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!okSpec) {errs <- base::c(errs, "[.spec] is not a valid property specification (?is_prop_spec).")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  errs <- base::paste0("[", labs, "] must be ", ppp::spec_concise(.spec), ".")
  for (i in 1:n) {
    val <- F
    if (.na ) {val <- base::is.na(base::...elt(i))}
    if (!val) {val <- ppp::PPP(base::...elt(i), .spec)}
    if (!val) {ppp::bankerr(errs[i], .gens = 1)}
  }
}

#' @rdname stopperr
#' @export
check_vals <- function(.vals, ..., .a = TRUE, .na = FALSE) {
  valid <- function(y) {
    if (base::is.atomic(y)) {base::all(base::sapply(ppp::av(y), base::`%in%`, table = .vals))}
    else if (base::is.data.frame(y)) {base::all(base::apply(y, 2, valid))}
    else if (base::is.list(y)) {base::all(base::sapply(y, valid))}
    else {F}
  }
  n      <- base::...length()
  labs   <- base::...names()
  okN    <- n > 0
  okA    <- ppp::.cmp_lgl_scl(.a)
  okNas  <- ppp::.cmp_lgl_scl(.na)
  okDots <- base::length(labs) == n
  okAnon <- !base::any(labs == "")
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  okVals <- ppp::.cmp_atm(.vals)
  errs   <- NULL
  if (!okN   ) {errs <- base::c(errs, "[...] is empty.")}
  if (!okA   ) {errs <- base::c(errs, "[.a] must be TRUE or FALSE.")}
  if (!okNas ) {errs <- base::c(errs, "[.na] must be TRUE or FALSE.")}
  if (!okVals) {errs <- base::c(errs, "[.vals] must be complete and atomic (?cmp_atm).")}
  if (!okDots) {errs <- base::c(errs, "all [...] args must be named.")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\").")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  dots <- base::list(...)
  atm  <- base::sapply(dots, ppp::.POP) & base::sapply(dots, ppp::.aTM)
  if (.a & !base::all(atm)) {ppp::stopperr("When [.a = TRUE], all [...] args must be populated and atomic (?pop_atm).", .pkg = "ppp")}
  if (!.a) {
    vls <- base::sapply(dots, ppp::atm_vls)
    dtf <- base::sapply(dots, ppp::atm_dtf)
    if (!base::all(atm | vls | dtf)) {ppp::stopperr("All [...] args must be populated and atomic (?pop_atm), atomic vlists (?atm_vls), or atomic data.frames (?atm_dtf).", .pkg = "ppp")}
  }
  for (i in 1:n) {if (!valid(dots[[i]])) {ppp::bankerr("[", labs[i], "] contains 1 or more values not in [.vals].", .gens = 1, .d = "")}}
}

#' @rdname stopperr
#' @export
check_chars <- function(.chars, ..., .a = TRUE) {
  valid <- function(y) {
    if (base::is.character(y)) {
      y <- base::paste0(ppp::av(y), collapse = "")
      y <- ppp::av(base::strsplit(y, "", fixed = T))
      base::all(y %in% .chars)
    } else if (base::is.data.frame(y)) {base::all(base::apply(y, 2, valid))}
    else if (base::is.list(y)) {base::all(base::sapply(y, valid))}
    else {F}
  }
  n       <- base::...length()
  labs    <- base::...names()
  okN     <- n > 0
  okA     <- ppp::.cmp_lgl_scl(.a)
  okDots  <- base::length(labs) == n
  okAnon  <- !base::any(labs == "")
  okUnq   <- base::length(labs) == base::length(base::unique(labs))
  okChars <- ppp::.cmp_str(.chars)
  errs    <- NULL
  if (!okN    ) {errs <- base::c(errs, "[...] is empty.")}
  if (!okA    ) {errs <- base::c(errs, "[.a] must be TRUE or FALSE.")}
  if (!okChars) {errs <- base::c(errs, "[.chars] must be complete and of mode string (?cmp_str).")}
  if (!okDots ) {errs <- base::c(errs, "all [...] args must be named.")}
  if (!okAnon ) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\").")}
  if (!okUnq  ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  dots <- base::list(...)
  chr  <- base::sapply(dots, ppp::.POP) & base::sapply(dots, ppp::.CHR)
  if (.a | !base::all(chr)) {ppp::stopperr("When [.a = TRUE], all [...] args must be populated and of mode character (?pop_chr).", .pkg = "ppp")}
  if (!.a) {
    vls <- base::sapply(dots, chr_vls)
    dtf <- base::sapply(dots, chr_dtf)
    if (!base::all(chr | vls | dtf)) {ppp::stopperr("All [...] args must be populated and of mode character (?pop_chr), character vlists (?chr_vls), or character data.frames (?chr_dtf).", .pkg = "ppp")}
  }
  for (i in 1:n) {if (!valid(dots[[i]])) {ppp::bankerr("[", labs[i], "] contains 1 or more characters not in [.chars].", .gens = 1, .d = "")}}
}

#' @rdname stopperr
#' @export
check_dots <- function(.spec, ..., .named = FALSE) {
  n   <- base::...length()
  labs  <- base::...names()
  okDots <- ppp::.cmp_lgl_scl(.named)
  okSpec  <- ppp::.cmp_chr_vec(.spec)
  if (okSpec) {
    combos <- ppp::av(base::strsplit(.spec, "|", fixed = TRUE))
    for (combo in combos) {
      props <- ppp::av(base::strsplit(combo, "_", fixed = TRUE))
      if (!base::all(base::tolower(props) %in% ppp::all_props())) {okSpec <- FALSE}
      else if (base::length(props) != base::length(base::unique(props))) {okSpec <- FALSE}
    }}
  okN    <- n > 0
  okDots <- !base::isTRUE(.named) | base::length(labs) == n
  okAnon <- !base::any(labs == "")
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  errs <- NULL
  if (!okDots) {errs <- base::c(errs, "[.named] must be TRUE or FALSE.")}
  if (!okN   ) {errs <- base::c(errs, "[...] is empty.")}
  if (!okSpec) {errs <- base::c(errs, "[.spec] must be complete and character (?cmp_chr).")}
  if (!okDots) {errs <- base::c(errs, "all [...] args must be named with [.named = TRUE].")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\").")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  if (!base::all(base::sapply(base::list(...), ppp::PPP, spec = .spec))) {ppp::stopperr(base::paste0("All [...] args must be ", ppp::spec_concise(.spec), "."))}
}

#' @rdname stopperr
#' @export
check_when <- function(.whens, .vals, ...) {
  labs     <- base::...names()
  n        <- base::...length()
  okN      <- n == 2
  okDots   <- base::length(labs) == n
  okAnon   <- !base::any(labs == "")
  okUnq    <- base::length(labs) == base::length(base::unique(labs))
  okWhens  <- ppp::.pop_atm(.whens)
  okVals   <- ppp::.pop_atm(.vals)
  okNeq    <- base::length(.whens) == length(.vals)
  okScl    <- ppp::.atm_scl(..1) & ppp::.atm_scl(..2)
  okWhens2 <- base::ifelse(okWhens & okVals, uj:::.compat(.whens, ..1), T)
  okVals2  <- base::ifelse(okWhens & okVals, uj:::.compat(.vals , ..2), T)
  errs     <- NULL
  if (!okN     ) {errs <- base::c(errs, "There must be two [...] args")}
  if (!okDots  ) {errs <- base::c(errs, "all [...] args must be named.")}
  if (!okAnon  ) {errs <- base::c(errs, "[...] arg names may not be blank.")}
  if (!okUnq   ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!okVals  ) {errs <- base::c(errs, "[.vals] must be non-empty and atomic.")}
  if (!okWhens ) {errs <- base::c(errs, "[.whens] must be non-empty and atomic.")}
  if (!okNeq   ) {errs <- base::c(errs, "[.whens] and [.vals] must be of the same length.")}
  if (!okScl   ) {errs <- base::c(errs, "Both args in [...] must be atomic and scalar (?atm_scl).")}
  if (!okWhens2) {errs <- base::c(errs, "[.vals] and [..2] are of incompatible (?compatible) modes.")}
  if (!okVals2 ) {errs <- base::c(errs, "[.whens] and [..1] are of incompatible (?compatible) modes.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  labs1 <- base::paste0("[", labs[1], "]")
  labs2 <- base::paste0("[", labs[2], "]")
  when  <- ..1
  val   <- ..2
  i     <- base::which(base::sapply(.whens, uj::is_eq0, y = when))
  if (base::length(i) > 0) {
    match <- .vals[i[1]]
    okEq  <- base::length(val) == 1 & base::length(match) == 1
    if ( okEq) {okEq <- val == match}
    if (!okEq) {
      if (base::is.character(match)) {match <- base::paste0("'", match, "'")}
      ppp::bankerr("When ", labs1, " is ", when, ", ", labs2, " must be ", match, ".", .gens = 1, .d = "")
  }}
}

#' @rdname stopperr
#' @export
check_fail <- function(...) {
  n      <- base::...length()
  labs   <- base::...names()
  okN    <- n > 0
  okDots <- base::length(labs) == n
  okAnon <- !base::any(labs == "")
  okUnq  <- base::length(labs) == base::length(base::unique(labs))
  errs   <- NULL
  if (!okN   ) {errs <- base::c(errs, "[...] is empty.")}
  if (!okDots) {errs <- base::c(errs, "all [...] args must be named with [NAMED = TRUE].")}
  if (!okAnon) {errs <- base::c(errs, "[...] arg names may not be blank strings (\"\").")}
  if (!okUnq ) {errs <- base::c(errs, "[...] arg names must be unique.")}
  if (!base::is.null(errs)) {ppp::stopperr(errs, .pkg = "ppp")}
  for (i in 1:n) {if (uj::is_err(base::...elt(i))) {ppp::bankerr("evaluating arg [", labs[i], "] produced an error: ", ppp::av(base::...elt(i)), .gens = 1, .d = "")}}
}
